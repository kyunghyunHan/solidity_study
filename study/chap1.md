# 챕터 1
## 컨트랙트
- 솔리디티 코드는 컨트랙트 안에 싸여 있지. 컨트랙트는 이더리움 애플리케이션의 기본적인 구성 요소로, 모든 변수와 함수는 어느 한 컨트랙트에 속하게 마련이지. 컨트랙트는 자네의 모든 프로젝트의 시작 지점
```solidity
contract HelloWorld {

}
```
## 상태변수
- 상태 변수는 컨트랙트 저장소에 영구적으로 저장
```
contract Example {
  // 이 변수는 블록체인에 영구적으로 저장된다
  uint myUnsignedInteger = 100;
}
```
## 수학연산
```
덧셈: x + y
뺄셈: x - y,
곱셈: x * y
나눗셈: x / y
모듈로 / 나머지: x % y (이를테면, 13 % 5는 3이다. 왜냐면 13을 5로 나누면 나머지가 3이기 때문이다)
```
## 구조체
- 좀 더 복잡한 자료형을 필요로 할 때가 가끔 있을 거네. 이를 위해 솔리디티는 구조체를 제공
```sol
struct Person {
  uint age;
  string name;
}
```

## 배열
- 솔리디티에는 _정적_ 배열과 _동적_ 배열
```sol
// 2개의 원소를 담을 수 있는 고정 길이의 배열:
uint[2] fixedArray;
// 또다른 고정 배열으로 5개의 스트링을 담을 수 있다:
string[5] stringArray;
// 동적 배열은 고정된 크기가 없으며 계속 크기가 커질 수 있다:
uint[] dynamicArray;
```
```sol
Person[] people; // 이는 동적 배열로, 원소를 계속 추가할 수 있다.
```
- 상태 변수가 블록체인에 영구적으로 저장될 수 있다는 걸 기억하나? 그러니 이처럼 구조체의 동적 배열을 생성하면 마치 데이터베이스처럼 컨트랙트에 구조화된 데이터를 저장하는 데 유용하네.
- Public 배열 : 다른 컨트랙트들이 이 배열을 읽을 수 있게 되지 (쓸 수는 없네). 이는 컨트랙트에 공개 데이터를 저장할 때 유용한 패턴이지.
```sol
Person[] public people;
```
## 함수선언
- 함수 인자명을 언더스코어(_)로 시작해서 전역 변수와 구별하는 것이 관례이네 (의무는 아님). 

```sol
function eatHamburgers(string _name, uint _amount) {

}
```
## 구조체와 배열 활용하기

```sol
// 새로운 사람을 생성한다:
Person satoshi = Person(172, "Satoshi");

// 이 사람을 배열에 추가한다:
people.push(satoshi);
//이 두 코드를 조합하여 깔끔하게 한 줄로 표현할 수 있네:
people.push(Person(16, "Vitalik"));
```
